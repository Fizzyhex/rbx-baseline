[{"title":"Installation","type":0,"sectionRef":"#","url":"/rbx-baseline/docs/Installation","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Installation","url":"/rbx-baseline/docs/Installation#installation","content":"The latest version of this package is available on Wally, a package manager built for Roblox. To use Baseline, you need to run wally init on your project directory and then add it to your project as a dependancy. Here's what your wally.toml file could look like: wally.toml [package] name = &quot;your_name/your_project&quot; version = &quot;0.1.0&quot; registry = &quot;https://github.com/UpliftGames/wally-index&quot; realm = &quot;shared&quot; [dependencies] Baseline = &quot;fizzyhex/Baseline@x.3.x&quot; # This version number isn't valid! Go copy the latest version from Wally.  "},{"title":"Introduction","type":0,"sectionRef":"#","url":"/rbx-baseline/docs/intro","content":"Introduction Under Construction This documentation contains up-to-date information, but still a work in progress. Baseline is a functional library for Roblox that contains utilities for creating cleaner initalization scripts. It's a great tool for client/server scripts for experiences using SSA (single-script architecture), but it's very general purpose and may be appropriate for other applications. If you're interested, feel free to take a look at the API docs and concepts page for more info! ExampleInit.server.lua local Baseline = require(somewhere.Packages.Baseline) local ControllersFolder = somewhere.Controllers local moduleScriptFilter = Baseline.Filters.IsA(&quot;ModuleScript&quot;) -- Let's require any descendants that are a ModuleScript local controllers = Baseline.CallFor( Baseline.Filter(ControllersFolder:GetDescendants(), moduleScriptFilter), require ) -- Do controller:OnInit() for any controller that has an 'OnInit' method Baseline.CallMethods(controllers, &quot;OnInit&quot;) -- Do task.spawn(controller:OnStart()) for any controller that has an 'OnStart' method Baseline.SpawnMethods(controllers, &quot;OnStart&quot;) -- Print the table of all our loaded controllers print(&quot;Loaded all controllers!&quot;, controllers) ","keywords":""},{"title":"Concepts","type":0,"sectionRef":"#","url":"/rbx-baseline/docs/Concepts","content":"","keywords":""},{"title":"Filters​","type":1,"pageTitle":"Concepts","url":"/rbx-baseline/docs/Concepts#filters","content":""},{"title":"What are Filters?​","type":1,"pageTitle":"Concepts","url":"/rbx-baseline/docs/Concepts#what-are-filters","content":"Filters are simply functions that return true or false, very similarly to the filters in Sleitnick's TableUtil for example. info TableUtil works great in conjunction with Baseline. They both use the same syntax for filters, which makes filters written for both cross compatible. local function IsOverFive(x: number) return x &gt; 5 end local filteredNumbers = Baseline.Filter({3, 5, 6, 7, 8}, IsOverFive) -- { 6, 7, 8 } print(filteredNumbers)  "},{"title":"Making more reusable filters​","type":1,"pageTitle":"Concepts","url":"/rbx-baseline/docs/Concepts#making-more-reusable-filters","content":"Here's where the decorator pattern comes in to play. Say we want to take the above IsOverFive filter, and make it work with a broader range of numbers. We can achieve this using a decorator: local function IsOverFilterDecorator(min: number) return function(x: number) return x &gt; min end end local isOverFive = IsOverFilterDecorator(5) local isOverTwenty = IsOverFilterDecorator(20) -- { 6, 7 } print(Baseline.Filter({3, 4, 5, 6, 7}, isOverFive)) -- { 21, 22, 23 } print(Baseline.Filter({19, 20, 21, 22, 23}, isOverTwenty))  "},{"title":"Roblox Instance Filters​","type":1,"pageTitle":"Concepts","url":"/rbx-baseline/docs/Concepts#roblox-instance-filters","content":"Baseline comes with a bunch of useful filters for Roblox Instances by default. Check the API docs if you're interested in learning about all of those. local ZombiesContainer = ServerStorage.Zombies:GetChildren() local zombieFilter = Baseline.CombineFilters( Baseline.Filters.HasTag(&quot;Zombie&quot;), Baseline.Filters.IsA(&quot;Model&quot;) ) -- { FastZombie, ZombifiedCitizen, FireZombie, Zombie } print(Baseline.Filter(zombies, zombieFilter))  "},{"title":"Baseline","type":0,"sectionRef":"#","url":"/rbx-baseline/api/Baseline","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Baseline","url":"/rbx-baseline/api/Baseline#functions","content":" "},{"title":"CombineFilters​","type":1,"pageTitle":"Baseline","url":"/rbx-baseline/api/Baseline#CombineFilters","content":"&lt;/&gt; Baseline.CombineFilters( ...: ...Filter-- Filters to combine ) → Filter Combines multiple filters together to create one.  "},{"title":"InvertFilter​","type":1,"pageTitle":"Baseline","url":"/rbx-baseline/api/Baseline#InvertFilter","content":"&lt;/&gt; Baseline.InvertFilter( filter: Filter-- Filter to invert ) → Filter Wraps a filter and makes it return the opposite of what it would before. local enabledFilter = Baseline.InvertFilter(Baseline.Filters.HasTag(&quot;Disabled&quot;)) local children = ReplicatedStorage.Shared.Systems:GetChildren() Baseline.Filter(children, enabledFilter)   "},{"title":"Filter​","type":1,"pageTitle":"Baseline","url":"/rbx-baseline/api/Baseline#Filter","content":"&lt;/&gt; Baseline.Filter( tabl: {},-- Table to filter filter: Filter,-- Filter to run ...: ...Filter-- Additional filters to run ) → {} Iterates over a table and returns a table of content only accepted by the filter(s). local function SystemFilter(instance: Instance) -- The name must end in 'System' return instance.Name:match(&quot;System$&quot;) ~= nil end local children = { Systems.UnrelatedModule, Systems.RopeSystem, Systems.DodBetter, Systems.GameSystem } -- Output: { RopeSystem, GameSystem } print(Baseline.Filter(children, SystemFilter))   "},{"title":"CallForKeys​","type":1,"pageTitle":"Baseline","url":"/rbx-baseline/api/Baseline#CallForKeys","content":"&lt;/&gt; Baseline.CallForKeys( tabl: {},-- Table to iterate over func: function, ...: ...any-- Additional arguments to insert after key in the function call ) → results{}-- A table containing anything returned by your function Runs a function for every key in a table.  "},{"title":"CallForValues​","type":1,"pageTitle":"Baseline","url":"/rbx-baseline/api/Baseline#CallForValues","content":"&lt;/&gt; Baseline.CallForValues( tabl: {},-- Table to iterate over func: function, ...: ...any-- Additional arguments to insert after value in the function call ) → results{}-- A table containing anything returned by your function Runs a function for every value in a table. local zombies = { ZombiePrefabs.SlowZombie, ZombiePrefabs.MoneyZombie } -- Output: -- SlowZombie is a zombie! -- MoneyZombie is a zombie! Baseline.CallForValues(zombies, print, &quot;is a zombie!&quot;)   "},{"title":"CallFor​","type":1,"pageTitle":"Baseline","url":"/rbx-baseline/api/Baseline#CallFor","content":"&lt;/&gt; Baseline.CallFor( tabl: {},-- Table to iterate over func: function, ...: ...any-- Additional arguments to insert after value in the function call ) → results{}-- A table containing anything returned by your function Alias for CallForValues.  "},{"title":"CallForItems​","type":1,"pageTitle":"Baseline","url":"/rbx-baseline/api/Baseline#CallForItems","content":"&lt;/&gt; Baseline.CallForItems( tabl: {},-- Table to iterate over func: function, ...: ...any-- Additional arguments to insert after value &amp; key in the function call ) → results{}-- A table containing anything returned by your function Runs a function for every value in a table. Similar to table.foreach.  "},{"title":"CallMethods​","type":1,"pageTitle":"Baseline","url":"/rbx-baseline/api/Baseline#CallMethods","content":"&lt;/&gt; Baseline.CallMethods( tabl: {},-- Table to iterate over methodName: string,-- Name of the method to call ...: ...any-- Additional arguments to insert after value &amp; key in the function call ) → results{}-- A table containing anything returned by the method calls Calls a method on all items in a table, only if the method is present. local moduleContainer = Somewhere.Modules:GetChildren() Baseline.CallMethods(moduleContainer, &quot;ClearAllChildren&quot;) local maids = {Maid.new(), {}, Maid.new()} -- Calls :Clean() on all of the maids, ignoring the empty table Baseline.CallMethods(maids, &quot;Clean&quot;)   "},{"title":"SpawnMethods​","type":1,"pageTitle":"Baseline","url":"/rbx-baseline/api/Baseline#SpawnMethods","content":"&lt;/&gt; Baseline.SpawnMethods( tabl: {},-- Table to iterate over methodName: string,-- Name of the method to call ...: ...any-- Additional arguments to insert after value &amp; key in the function call ) → () Similar to CallMethods but method calls willbe wrapped in task.spawn too.  "},{"title":"Extend​","type":1,"pageTitle":"Baseline","url":"/rbx-baseline/api/Baseline#Extend","content":"&lt;/&gt; Baseline.Extend(...: ...{[any]: any}) → results{} Combines multiple arrays. info This function does not mutate your tables, and instead returns a new table with your arrays combined. local t1 = {&quot;a&quot;, &quot;b&quot;} local t2 = {&quot;c&quot;, &quot;d&quot;} local t3 = {&quot;e&quot;, &quot;f&quot;} local composition = Baseline.Extend(t1, t2, t3) -- Output: { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot; } print(composition)  "}]