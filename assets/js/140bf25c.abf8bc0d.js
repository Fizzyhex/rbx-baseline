"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[986],{9730:e=>{e.exports=JSON.parse('{"functions":[{"name":"CombineFilters","desc":"Combines multiple filters together to create one.","params":[{"name":"...","desc":"Filters to combine","lua_type":"...Filter"}],"returns":[{"desc":"","lua_type":"Filter"}],"function_type":"static","source":{"line":91,"path":"lib/init.lua"}},{"name":"InvertFilter","desc":"Wraps a filter and makes it return the opposite of what it would before.\\n\\n```lua\\nlocal enabledFilter = Baseline.InvertFilter(Baseline.Filters.HasTag(\\"Disabled\\"))\\n\\nlocal children = ReplicatedStorage.Shared.Systems:GetChildren()\\nBaseline.Filter(children, enabledFilter)\\n```","params":[{"name":"filter","desc":"Filter to invert","lua_type":"Filter"}],"returns":[{"desc":"","lua_type":"Filter"}],"function_type":"static","source":{"line":118,"path":"lib/init.lua"}},{"name":"Filter","desc":"Iterates over a table and returns a table of content only accepted by the filter(s).\\n\\n```lua\\nlocal function SystemFilter(instance: Instance)\\n\\t-- The name must end in \'System\'\\n\\treturn instance.Name:match(\\"System$\\") ~= nil\\nend\\n\\nlocal children = {\\n\\tSystems.UnrelatedModule,\\n\\tSystems.RopeSystem,\\n\\tSystems.DodBetter,\\n\\tSystems.GameSystem\\n}\\n\\n-- Output: { RopeSystem, GameSystem }\\nprint(Baseline.Filter(children, SystemFilter))\\n```","params":[{"name":"tabl","desc":"Table to filter","lua_type":"{}"},{"name":"filter","desc":"Filter to run","lua_type":"Filter"},{"name":"...","desc":"Additional filters to run","lua_type":"...Filter"}],"returns":[{"desc":"","lua_type":"{}"}],"function_type":"static","source":{"line":149,"path":"lib/init.lua"}},{"name":"CallForKeys","desc":"Runs a function for every key in a table.","params":[{"name":"tabl","desc":"Table to iterate over","lua_type":"{}"},{"name":"func","desc":"","lua_type":"function"},{"name":"...","desc":"Additional arguments to insert after key in the function call","lua_type":"...any"}],"returns":[{"desc":"A table containing anything returned by your function","lua_type":"results {}"}],"function_type":"static","source":{"line":188,"path":"lib/init.lua"}},{"name":"CallForValues","desc":"Runs a function for every value in a table.\\n\\n```lua\\nlocal zombies = {\\n\\tZombiePrefabs.SlowZombie,\\n\\tZombiePrefabs.MoneyZombie\\n}\\n\\n-- Output:\\n-- SlowZombie is a zombie!\\n-- MoneyZombie is a zombie!\\nBaseline.CallForValues(zombies, print, \\"is a zombie!\\")\\n```","params":[{"name":"tabl","desc":"Table to iterate over","lua_type":"{}"},{"name":"func","desc":"","lua_type":"function"},{"name":"...","desc":"Additional arguments to insert after value in the function call","lua_type":"...any"}],"returns":[{"desc":"A table containing anything returned by your function","lua_type":"results {}"}],"function_type":"static","source":{"line":219,"path":"lib/init.lua"}},{"name":"CallFor","desc":"Alias for CallForValues.","params":[{"name":"tabl","desc":"Table to iterate over","lua_type":"{}"},{"name":"func","desc":"","lua_type":"function"},{"name":"...","desc":"Additional arguments to insert after value in the function call","lua_type":"...any"}],"returns":[{"desc":"A table containing anything returned by your function","lua_type":"results {}"}],"function_type":"static","source":{"line":238,"path":"lib/init.lua"}},{"name":"CallForItems","desc":"Runs a function for every value in a table. Similar to `table.foreach`.","params":[{"name":"tabl","desc":"Table to iterate over","lua_type":"{}"},{"name":"func","desc":"","lua_type":"function"},{"name":"...","desc":"Additional arguments to insert after value & key in the function call","lua_type":"...any"}],"returns":[{"desc":"A table containing anything returned by your function","lua_type":"results {}"}],"function_type":"static","source":{"line":250,"path":"lib/init.lua"}},{"name":"CallMethods","desc":"Calls a method on all items in a table, only if the method is present.\\n\\n```lua\\nlocal moduleContainer = Somewhere.Modules:GetChildren()\\nBaseline.CallMethods(moduleContainer, \\"ClearAllChildren\\")\\n\\nlocal maids = {Maid.new(), {}, Maid.new()}\\n-- Calls :Clean() on all of the maids, ignoring the empty table\\nBaseline.CallMethods(maids, \\"Clean\\")\\n```","params":[{"name":"tabl","desc":"Table to iterate over","lua_type":"{}"},{"name":"methodName","desc":"Name of the method to call","lua_type":"string"},{"name":"...","desc":"Additional arguments to insert after value & key in the function call","lua_type":"...any"}],"returns":[{"desc":"A table containing anything returned by the method calls","lua_type":"results {}"}],"function_type":"static","source":{"line":281,"path":"lib/init.lua"}},{"name":"SpawnMethods","desc":"Similar to `CallMethods` but method calls willbe wrapped in `task.spawn` too.","params":[{"name":"tabl","desc":"Table to iterate over","lua_type":"{}"},{"name":"methodName","desc":"Name of the method to call","lua_type":"string"},{"name":"...","desc":"Additional arguments to insert after value & key in the function call","lua_type":"...any"}],"returns":[],"function_type":"static","source":{"line":305,"path":"lib/init.lua"}},{"name":"Extend","desc":"Combines multiple arrays.\\n\\n:::info\\nThis function does not mutate your tables, and instead returns a new table with your arrays combined.\\n:::\\n\\n```lua\\nlocal t1 = {\\"a\\", \\"b\\"}\\nlocal t2 = {\\"c\\", \\"d\\"}\\nlocal t3 = {\\"e\\", \\"f\\"}\\nlocal composition = Baseline.Extend(t1, t2, t3)\\n-- Output: { \\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\" }\\nprint(composition)\\n```","params":[{"name":"...","desc":"","lua_type":"...{[any]: any}"}],"returns":[{"desc":"","lua_type":"results {}"}],"function_type":"static","source":{"line":336,"path":"lib/init.lua"}}],"properties":[],"types":[],"name":"Baseline","desc":"The best friend of your initializer scripts.\\n\\n```lua title=\\"ExampleInit.server.lua\\"\\nlocal Baseline = require(somewhere.Packages.Baseline)\\nlocal ControllersFolder = somewhere.Controllers\\n\\nlocal moduleScriptFilter = Baseline.Filters.IsA(\\"ModuleScript\\")\\n\\n-- Let\'s require any descendants that are a ModuleScript\\nlocal controllers = Baseline.CallFor(\\n\\tBaseline.Filter(ControllersFolder:GetDescendants(), moduleScriptFilter),\\n\\trequire\\n)\\n\\n-- Do controller:OnInit() for any controller that has an \'OnInit\' method\\nBaseline.CallMethods(controllers, \\"OnInit\\")\\n-- Do task.spawn(controller:OnStart()) for any controller that has an \'OnStart\' method\\nBaseline.SpawnMethods(controllers, \\"OnStart\\")\\n-- Print the table of all our loaded controllers\\nprint(\\"Loaded all controllers!\\", controllers)\\n```","source":{"line":30,"path":"lib/init.lua"}}')}}]);